name: Deploy to the gh-pages branch

on:
  pull_request_target:
    branches:
      - main
  push:
    branches:
      - main
  workflow_dispatch:

permissions:
  contents: write

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Generate a token
        id: generate-token
        uses: actions/create-github-app-token@v2
        with:
          app-id: ${{ secrets.CONJURE_BOT_ID }}
          private-key: ${{ secrets.CONJURE_BOT_PRIVATE_KEY }}

      - name: Checkout PR
        if: ${{ github.event_name == 'pull_request_target' }}
        uses: actions/checkout@v6
        with:
          # Avoid checkout's default auth header so deploy uses the app token.
          repository: ${{ github.event.pull_request.head.repo.full_name }}
          ref: ${{ github.event.pull_request.head.sha }}
          persist-credentials: false

      - name: Checkout repository
        if: ${{ github.event_name != 'pull_request_target' }}
        uses: actions/checkout@v6
        with:
          # Avoid checkout's default auth header so deploy uses the app token.
          persist-credentials: false

      - uses: actions/setup-node@v4
        with:
          node-version: 21
          cache: npm

      - name: Build
        run: |
          npm ci
          npm run build
          # creates a .nojekyll file in the out directory to tell GitHub Pages not to treat the site as a Jekyll project.
          touch dist/.nojekyll

      - name: Set deploy target
        id: deploy
        run: |
          if [[ "${{ github.event_name }}" == "pull_request_target" ]]; then
            echo "folder=pr/${{ github.event.pull_request.number }}" >> "$GITHUB_OUTPUT"
            echo "label=pr-${{ github.event.pull_request.number }}" >> "$GITHUB_OUTPUT"
          else
            echo "folder=main" >> "$GITHUB_OUTPUT"
            echo "label=main" >> "$GITHUB_OUTPUT"
          fi

      - name: Create reports app token
        id: reports-token
        uses: actions/create-github-app-token@v2
        with:
          app-id: ${{ secrets.CONJURE_BOT_ID }}
          private-key: ${{ secrets.CONJURE_BOT_PRIVATE_KEY }}
          owner: ${{ github.repository_owner }}
          repositories: |
            conjure-oxide-reports

      - name: Create conjure-bot token
        if: ${{ github.event_name == 'pull_request_target' }}
        id: bot-token
        uses: actions/create-github-app-token@v2
        with:
          app-id: ${{ secrets.CONJURE_BOT_ID }}
          private-key: ${{ secrets.CONJURE_BOT_PRIVATE_KEY }}

      - name: Comment preview on PR
        if: ${{ github.event_name == 'pull_request_target' }}
        continue-on-error: true
        uses: actions/github-script@v8
        env:
          REPORT_URL: https://${{ github.repository_owner }}.github.io/conjure-blocks-reports/pr/${{ github.event.pull_request.number }}
        with:
          github-token: ${{ steps.bot-token.outputs.token }}
          script: |
            const prNumber = context.payload.pull_request?.number;
            if (!prNumber) return;

            try {
              const marker = "<!-- report -->";
              const body = [
                marker,
                "## Conjure Blocks Preview",
                "",
                `Preview: ${process.env.REPORT_URL}`
              ].join("\n");

              const comments = await github.paginate(github.rest.issues.listComments, {
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                per_page: 100
              });

              // Keep a single docs preview comment per PR: update newest, delete older duplicates.
              const matching = comments
                .filter(c => c.body?.includes(marker))
                .sort((a, b) => Date.parse(b.updated_at) - Date.parse(a.updated_at));

              let keepComment;

              if (matching.length > 0) {
                keepComment = matching[0];
                await github.rest.issues.updateComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  comment_id: keepComment.id,
                  body
                });
              } else {
                const created = await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: prNumber,
                  body
                });
                keepComment = created.data;
              }

              for (const comment of matching) {
                if (comment.id === keepComment.id) continue;
                try {
                  await github.rest.issues.deleteComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    comment_id: comment.id
                  });
                } catch (deleteError) {
                  console.log(`Skipping preview comment cleanup for ${comment.id}: ${deleteError.message || deleteError}`);
                }
              }
            } catch (error) {
              console.log(`Skipping preview PR comment: ${error.message || error}`);
            }